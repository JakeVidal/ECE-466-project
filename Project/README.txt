
PROJECT: Hardware-Software Co-simulation


We will use Diffie-Hellman key exchange protocol, originally written in C 
and distributed as a part of the NetBench benchmark suite.  The original 
source files have been converted into a single file: dhdemo_original.cpp
(available on the course website for your reference).  We will rewrite it 
using SystemC and model one of its computationally intensive functions, 
NN_DigitMult, as a hardware module (i.e., datapath + controller).

First, download the following 7 files from the course website: Makefile, 
dhdemo.cpp, dh_sw.h, dh_sw.cpp, dh_hw_mult.h, dh_hw_mult.cpp, digit.h. 
Compile them using Makefile and run SystemC executable main.x.  The
output should look like this:

*** Agreed Key:  09 2a f1 41 e2 93 61 d5 
*** Agreed Key:  64 30 94 c5 da d2 f6 da 49 6d 67 f1 16 55 b3 ea ee a2 c0 30 2b b5 4f 05 9e a4 58 ac 97 3b b9 a0 25 b7 56 fe 82 73 bb 22 d4 31 36 60 7f 41 e9 47 97 b9 5e 27 99 3e 73 f0 28 da b5 25 da e4 61 84 

Now take a look at sc_main() in dhdemo.cpp, where we instantiate modules 
DH_SW (software) and DH_HW_MULT (hardware multiplier).  In addition to 
the data signals (operand1, operand2, result1, result2), there are two 
control signals exchanged between software and hardware: enable and done.
The enable signal is generated by software to enable hardware multiplication, 
and the done signal is generated by hardware to indicate that multiplication 
has been completed.  One of your tasks will be to implement an appropriate 
handshaking protocol using these two signals.  Currently, software and 
hardware are synchronized using only enable and explicit timing delays. 
(As an example, we use 100 ns for computation and 10 ns for communication.)

DH_HW_MULT is an instance of the dh_hw_mult module, with a THREAD process
sensitive to the enable signal.  DH_SW is an instance of the dh_sw module, 
with a THREAD process sensitive to the done signal.  The current version 
of the dh_hw_mult module does NOT generate done.  Hence, software-hardware
communication has to rely on timed waits at this point.

Your first task is to replace timed waits with the enable-done handshaking
protocol in both hardware (dh_hw_mult) and software (dh_sw).  For example,
the hardware should wait for enable signal to be asserted.  Once enable has
been asserted (by the software), the hardware should perform multiplication.
Then, it should output the result and assert done.  The hardware should
deassert done only if enable has been deasserted.  To implement this, you 
need to: (1) add a clock input to the hardware and make it a CTHREAD, and
(2) code a simple FSM with 4 states: 
 a. WAIT - wait for the enable signal to be asserted. 
 b. EXECUTE - multiply the two inputs (use the multiplication code as is). 
 c. OUTPUT - write to the module's output ports, assert the done signal. 
 d. FINISH - check if enable is deasserted; if so, deassert done.

NOTE: NN_DigitMult (dh_sw.cpp) also needs to be modified to complete your 
handshaking protocol.  Do NOT feed any clocks to the software module!  
There must be NO timed waits (e.g., wait(10, SC_NS)) in your final code.

Your second task is to design the datapath and controller of the hardware
multiplier.  You need to extract the multiplication code inside the EXECUTE 
state and convert it to the structural description using familiar registers,
multiplexers, shifters, adders, multipliers, etc.  Then, you need to split
the EXECUTE state into as many states as necessary to control your datapath.
Thus, your datapath controller becomes "embedded" into the handshaking FSM.
(Alternatively, you can separate the datapath controller and the handshaking
FSM into two communicating state machines.)

Your final design should produce the same output as the original code.
Beware that simulations will slow down as you refine your design.


UNDERGRADUATE Students: Please submit your compressed design directory
via the ECE 466 CourseSpaces webpage before the deadline.

GRADUATE students: Please email your compressed design directory to 
daler@ece.uvic.ca before the deadline.


Also, please submit a hardcopy of your report in the ELEC 466 drop-box 
before the deadline.


*********************************************
EXTRA CREDIT - 5% of the *TOTAL* course mark:

Once your hardware multiplier works, apply the same design steps to create
the hardware divisor (function NN_DigitDiv).  

Please email your compressed design directory to daler@ece.uvic.ca before 
the deadline (as a separate submission).

example output for testing
a[0] = 2147483648, a[1] = 0
a[0] = 2147483648, a[1] = 554094031
a[0] = 2147483648, a[1] = 573719873
a[0] = 0, a[1] = 573719874
a[0] = 3758096384, a[1] = 286859936
a[0] = 0, a[1] = 286859937
a[0] = 0, a[1] = 143429968
a[0] = 4, a[1] = 0
a[0] = 8, a[1] = 0
a[0] = 1, a[1] = 0
a[0] = 1, a[1] = 0
a[0] = 4, a[1] = 0
a[0] = 16, a[1] = 0
a[0] = 256, a[1] = 0
a[0] = 65536, a[1] = 0
a[0] = 0, a[1] = 1
a[0] = 2294879497, a[1] = 0
a[0] = 3705383900, a[1] = 1
a[0] = 2589671195, a[1] = 1
a[0] = 1932749185, a[1] = 289831040
a[0] = 210987277, a[1] = 289831040
a[0] = 16790672, a[1] = 690218077
a[0] = 2003746598, a[1] = 690218076
a[0] = 3151553729, a[1] = 40150
a[0] = 1193108671, a[1] = 40150
a[0] = 317587460, a[1] = 893023574
a[0] = 2034005927, a[1] = 893023573
a[0] = 2269354656, a[1] = 0
a[0] = 220521472, a[1] = 1199070959
a[0] = 1001732290, a[1] = 1199070958
a[0] = 4108199673, a[1] = 345907428
a[0] = 1494186193, a[1] = 345907428
a[0] = 4039905729, a[1] = 23712985
a[0] = 2279697273, a[1] = 23712985
a[0] = 3886117952, a[1] = 721387054
a[0] = 2384348295, a[1] = 721387054
a[0] = 1712111332, a[1] = 1
a[0] = 294791698, a[1] = 1
a[0] = 4272651332, a[1] = 467709019
a[0] = 1635806251, a[1] = 467709019
a[0] = 3092799744, a[1] = 27227322
a[0] = 1546025316, a[1] = 27227322
a[0] = 3093548856, a[1] = 0
a[0] = 2294879497, a[1] = 0
a[0] = 3388232865, a[1] = 148516321
a[0] = 2456943620, a[1] = 148516321
a[0] = 2485145673, a[1] = 201933937
a[0] = 1496675575, a[1] = 201933937
a[0] = 3587008068, a[1] = 227492566
a[0] = 2799490115, a[1] = 227492566
a[0] = 1898259457, a[1] = 144397962
a[0] = 4219866250, a[1] = 144397961
a[0] = 3946721006, a[1] = 0
a[0] = 2294879497, a[1] = 0
a[0] = 32540377, a[1] = 635297124
a[0] = 2761422578, a[1] = 635297123
a[0] = 364110449, a[1] = 571045681
a[0] = 3298750858, a[1] = 571045680
a[0] = 2720653774, a[1] = 0
a[0] = 2294879497, a[1] = 0
a[0] = 2978647961, a[1] = 42208408
a[0] = 798630089, a[1] = 42208408

